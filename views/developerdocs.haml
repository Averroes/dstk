.clearer{:style=>"clear:both"}

  .subtitle{:style=>"margin-top:-20px; font-size: 125%;"}

  .toc{:style=>"margin-top:30px; margin-bottom:30px; font-size: 125%;"}
    %a{:href=>"#usage"} Usage
    %br
    &nbsp;&nbsp;&nbsp;&nbsp;
    %a{:href=>"#geodict"} Geodict
    %br
    &nbsp;&nbsp;&nbsp;&nbsp;
    %a{:href=>"#text2places"} Text to Places
    %br
    &nbsp;&nbsp;&nbsp;&nbsp;
    %a{:href=>"#ip2coordinates"} IP Address to Location
    %br
    &nbsp;&nbsp;&nbsp;&nbsp;
    %a{:href=>"#street2coordinates"} Street Address to Location
    %br
    &nbsp;&nbsp;&nbsp;&nbsp;
    %a{:href=>"#coordinates2politics"} Location to Politics
    %br
    &nbsp;&nbsp;&nbsp;&nbsp;
    %a{:href=>"#file2text"} File to Text
    %br
    &nbsp;&nbsp;&nbsp;&nbsp;
    %a{:href=>"#text2sentences"} Text to Sentences
    %br
    &nbsp;&nbsp;&nbsp;&nbsp;
    %a{:href=>"#html2text"} HTML to Text
    %br
    &nbsp;&nbsp;&nbsp;&nbsp;
    %a{:href=>"#html2story"} HTML to Story
    %br
    %a{:href=>"#setup"} Setting up your own server
    %br
    &nbsp;&nbsp;&nbsp;&nbsp;
    %a{:href=>"#amazon"} Amazon EC2
    %br
    &nbsp;&nbsp;&nbsp;&nbsp;
    %a{:href=>"#vmware"} VMware
    %br

  .developerinfo{:style=>"margin-top:20px; font-size: 125%;"}

    %a{:name=>"usage"}
    :markdown
      ### Usage
      
    %br
    %a{:name=>"geodict"}
    :markdown
      #### Geodict

      As an emulation of Yahoo's service, a good place to start is [their Placemaker documentation](http://developer.yahoo.com/geo/placemaker/guide/web-service.html). There's also concrete examples of how to call the Placemaker API in the test_suite folder, and for Javascript in the source of the home page of this server. I've focused on supporting the most commonly used features of Yahoo's interface, so if you have some code that relies on something that's missing, [email me a sample of your source](mailto:pete@petewarden.com) and I'll do my best to add that in.
    
      Here's how the [Ushahidi Swift project](http://swift.ushahidi.com) calls Placemaker to pull the first location mentioned in a document.
    
      For the original Yahoo API:
      <hr>
      `define('BASE_URL', 'http://wherein.yahooapis.com/');`
      
      `define('APP_ID', '<Their API Key>');`
      <hr>
      
      Using GeodictAPI:
      
      <hr>
      `define('BASE_URL', 'http://www.geodictapi.com/');`
      
      `define('APP_ID', ''); // No API key needed`
      <hr>
      
      Code for calling the API and parsing the results:
      
      <hr>
      `$encodedLocation = \urlencode($location);`
      
      `$url = BASE_URL."v1/document";`

      `$postvars = "documentContent=$encodedLocation&documentType=text/plain&appid=$appid";`

      `$return = curl_request($url, $postvars);`

      `$xml = new \SimpleXMLElement($return);`

      `$long = (float) $xml->document->placeDetails->place->centroid->longitude;`

      `$latt = (float) $xml->document->placeDetails->place->centroid->latitude;`
      <hr>
      
      The results will differ between the two APIs, as the algorithms are quite different. In particular, I designed Geodict for applications that are intolerant of false positives, so for example Placemaker will flag "New York Times" as a location whereas Geodict will ignore it.


    %a{:name=>"text2places"}
    :markdown
      #### Text to Places
      
      This is the friendly interface to the same underlying functionality as Geodict. It uses a much simpler JSON format, taking an array with a single string as its input and returning an array of the locations found in that text. Here's an example:
      <hr>
      `curl "http://www.geodictapi.com/text2places/%5b%22Cairo%2c+Egypt%22%5d"`
      
      `[{"type":"CITY","start_index":"0","end_index":"4","matched_string":"Cairo, Egypt",`

      ` "latitude":"30.05","longitude":"31.25","name":"Cairo"}]`
      <hr>

    %a{:name=>"ip2coordinates"}
    :markdown
      #### IP Address to Location
      
      This API takes either a single numerical IP address, a comma-separated list, or a JSON-encoded array of addresses, and returns a JSON object with a key for every IP. The value for each key is either null if no information was found for the address, or an object containing location information, including country, region, city and latitude/longitude coordinates. Here's an example:
      <hr>
      `{"67.169.73.113":{`
      
      `"country_name":"United States",`
      
      `"area_code":415,`
      
      `"region":"CA",`
      
      `"postal_code":"94114",`
      
      `"city":"San Francisco",`
      
      `"latitude":37.7587013244629,`
      
      `"country_code":"US",`
      
      `"longitude":-122.438102722168,`
      
      `"country_code3":"USA",`
      
      `"dma_code":807}};`
      <hr>

      To call the API, you can make either a GET or a POST request to `/ip2coordinates`. If you make a GET request, then you need to pass in the IP addresses in the suffix of the URL, eg `/ip2coordinates/130.12.1.34%2C67.169.73.113`.

      Using GET you can also pass in a callback parameter in the URL, making it possible to run this as a JSONP cross-domain request. You can see this method in action if you view source on the home page of this server.
      
      You can also make a POST request passing in the IP addresses in the body of the request. This is useful if you have very large arrays of IP addresses you need to process, since you won't hit any URL size limits.
      
      This API uses data from [http://www.maxmind.com/](http://www.maxmind.com/).
      

    %a{:name=>"street2coordinates"}
    :markdown
      #### Street Address to Location
      
      This API takes either a single string representing a postal address, or a JSON-encoded array of addresses, and returns a JSON object with a key for every address. The value for each key is either null if no information was found for the address, or an object containing location information, including country, region, city and latitude/longitude coordinates. Here's an example:
      <hr>
      `curl "http://ww.geodictapi.com/street2coordinates/2543+Graystone+Place%2c+Simi+Valley%2c+CA+93065"`
      
      `{"2543 Graystone Place, Simi Valley, CA 93065":{`

      `"street_name":"Graystone Pl",`

      `"country_code":"US",`

      `"latitude":34.280874,`

      `"street_address":"2543 Graystone Pl",`

      `"country_code3":"USA",`

      `"fips_county":"06111",`

      `"longitude":-118.766207,`

      `"country_name":"United States",`

      `"confidence":0.922,`

      `"region":"CA",`

      `"street_number":"2543",`

      `"locality":"Simi Valley"}}`
      <hr>

      To call the API, you can make either a GET or a POST request to `/street2coordinates`. If you make a GET request, then you need to pass in the addresses in the suffix of the URL, as above.

      Using GET you can also pass in a callback parameter in the URL, making it possible to run this as a JSONP cross-domain request. You can see this method in action if you view source on the home page of this server.
      
      You can also make a POST request passing in the addresses in the body of the request. This is useful if you have very large arrays of addresses you need to process, since you won't hit any URL size limits.
      
      This API uses data from the US Census and code from [Schuyler Erle](https://github.com/geocommons/geocoder).


    %a{:name=>"coordinates2politics"}
    :markdown
      #### Location to Politics
      
      This API takes either a single string representing a comma-separated pair of latitude/longitude coordinates, or a JSON-encoded array of objects containing two keys, one for latitude and one for longitude. It returns a JSON array containing an object for every input location. The location member holds the coordinates that were queried, and politics holds an array of countries, states, provinces, cities, constituencies and neighborhoods that the point lies within. Here's an example:
      <hr>
      `curl "http://www.geodictapi.com/coordinates2politics/37.769456%2c-122.429128"`
      
      `[{"location":{"latitude":"37.769456","longitude":"-122.429128"},"politics":[`
      
      `{"type":"admin2","code":"usa","friendly_type":"country","name":"United States"},`
      
      `{"type":"admin4","code":"us06","friendly_type":"state","name":"California"},`
      
      `{"type":"admin6","code":"06_075","friendly_type":"county","name":"San Francisco"},`
      
      `{"type":"admin5","code":"06_67000","friendly_type":"city","name":"San Francisco"},`
      
      `{"type":"constituency","code":"06_08","friendly_type":"constituency","name":"Eighth district, CA"}]}]`
      <hr>

      To combat errors caused by lack of precision, there's a small amount of fuzziness built into the algorithm, so that points that lie very close to borders get information on both possible areas they could be within.
      
      To call the API, you can make either a GET or a POST request to `/coordinates2politics`. If you make a GET request, then you need to pass in the locations in the suffix of the URL, as above.

      Using GET you can also pass in a callback parameter in the URL, making it possible to run this as a JSONP cross-domain request. You can see this method in action if you view source on the home page of this server.
      
      You can also make a POST request passing in the locations in the body of the request. This is useful if you have very large arrays of locations you need to process, since you won't hit any URL size limits.

      This API relies on data gathered by volunteers around the world for [OpenHeatMap](http://www.openheatmap.com/), along with US census information and [neighborhood maps from Zillow](http://www.zillow.com/howto/api/neighborhood-boundaries.htm).


    %a{:name=>"file2text"}
    :markdown
      #### File to Text
      
      If you pass in an image, this API will run an optical character recognition algorithm to extract any words or sentences it can from the picture. If you upload a PDF file, Word document, Excel spreadsheet or HTML file, it will return a plain text version of the content. Unlike most of the calls, this one takes its input in the standard multipart form-encoded format that's used when browsers upload files, rather than as JSON. It returns any content it finds as a stream of text.
      <hr>
      `curl --form inputfile=@ExecutiveSummary.docx "http://www.geodictapi.com/file2text"`

      `OverviewMoveableCode, inc. is a seed stage company funded by a National Science Foundation Phase 1 SBIR grant.  The company is developing software applications for mobile devices with a particular emphasis on Augmented Reality (AR).`
      <hr>

      This API relies on the [Ocropus project](http://code.google.com/p/ocropus/) for handling images, and [catdoc](http://wagner.pp.ru/~vitus/software/catdoc/) for pre-XML Word and Excel documents.

    %a{:name=>"text2sentences"}
    :markdown
      #### Text to Sentences
      
      This call takes some text, and returns any fragments of it that look like proper sentences organized into paragraphs. It's most useful for taking documents that may be full of uninteresting boilerplate like headings and captions, and returning only the descriptive passages for further analysis.
      <hr>
      `curl -d "*Does*not*look_like999A sentence." "http://www.geodictapi.com/text2sentences"`
      
      `{"sentences":""}`

      `curl -d "But this does, it contains enough words. So does this one, it appears correct. This is long and complete enough too." "http://www.geodictapi.com/text2sentences"`
      
      `{"sentences":"But this does, it contains enough words. So does this one, it appears correct. This is long and complete enough too. \n"}`
      
      <hr>

      The GET form of this call takes a JSON-encoded array of a single string containing the text to analyze. This string must be less than about 8,000 characters long, or the URL size limit will be exceeded. The Javascript interface automatically switches to POST for long text requests, which means they will not work cross-domain.
      
      The POST form takes the input text as a single raw string in the body of the request. The result is a JSON-encoded object with a "sentences" member containing the matching parts of the input.

    %a{:name=>"html2text"}
    :markdown
      #### HTML to Text
      
      This call takes an HTML document, and analyzes it to determine what text would be displayed when it is rendered. This includes all headers, ads and other boilerplate. If you want only the main body text (for example the story section in a news article) then you should use [html2story](#html2story) on the HTML. 
      <hr>
      `curl -d "<html><head><title>MyTitle</title></head><body><script type="text/javascript">something();</script><div>Some actual text</div></body></html>" "http://www.geodictapi.com/html2text"`
      
      `{"text":"Some actual text\n"}`
      
      <hr>

      The GET form of this call takes a JSON-encoded array of a single string containing the text to analyze. This string must be less than about 8,000 characters long, or the URL size limit will be exceeded. The Javascript interface automatically switches to POST for long text requests, which means they will not work cross-domain.
      
      The POST form takes the input text as a single raw string in the body of the request. The result is a JSON-encoded object with a "text" member containing the matching parts of the input.

      This API relies on the [Hpricot](http://hpricot.com/) library to parse the HTML.

    %a{:name=>"text2story"}
    :markdown
      #### Text to Story
      
      This call takes an HTML document, and extracts the sections of text that appear to be the main body of a news story, or more generally the long, descriptive passages in any page. This is especially useful when you want to run an analysis only on the unique content of each page, ignoring all the repeated navigation elements.
      <hr>
      `curl -d "`*The contents of a real page*`" "http://www.geodictapi.com/html2story"`
      
      `{"story":"`*The story text*`"}`
      
      <hr>

      This one is tough to demonstrate in a succinct example, because it requires a non-trivial document before it will accept its contents as a valid story. 

      The GET form of this call takes a JSON-encoded array of a single string containing the text to analyze. This string must be less than about 8,000 characters long, or the URL size limit will be exceeded. The Javascript interface automatically switches to POST for long text requests, which means they will not work cross-domain.
      
      The POST form takes the input text as a single raw string in the body of the request. The result is a JSON-encoded object with a "story" member containing the matching parts of the input.

      This API relies on the [Boilerpipe](http://code.google.com/p/boilerpipe/) library to recognize and extract the story text.
      
    %a{:name=>"setup"}
    :markdown
      ### Setting up your own server

      You can get started using the "http://www.geodictapi.com/" server, but for intensive use or to run behind a firewall, you'll probably want to create your own machine.

    %a{:name=>"amazon"}
    :markdown
      The simplest way to create a server is to grab a virtual machine. This whole server is available ready-to-go as either a VMware or Amazon EC2 Image. 
      
      For Amazon, find the AMI with the id `ami-f639cb9f`. Start a new instance from this image, wait a couple of minutes for the machine to boot up, and then paste the public DNS name of the instance into your browser. You should see the normal home page of this site. You can test that it's working by pasting text into the main input. You can then just change your code base URL to that DNS name, and start using the API from your own server immediately.

    %a{:name=>"vmware"}
    :markdown
      For VMware, first [download the free Player application](http://www.vmware.com/products/player/). Then [download the Virtual Application image for the server](http://static.openheatmap.com/geodictapi_v1.20.vmwarevm.tar.bz2) and unzip it. Start up the VM, log in as 'ubuntu'/'changeme', and then type `ifconfig`. This will give you the VM's local IP address, so if you type that into the console you'll bring up this website, and be able to use it as an API endpoint.

      If you want to roll your own server from source on an in-house machine, or on another hosting provider, serversetup.txt contains instructions on the exact steps I took to create that image starting from a clean Ubuntu 10.04 installation.
